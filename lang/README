Glyr provides a interface file (glyr.i) to provide bindings for languages other than C/C++
To generate the wrapping code you should install SWIG and the devel headers of your scripting language
(+ all dependecies of glyr..)

As example for ruby, building 'glubyr.so'

# let SWIG generate the wrapper code
# This will create a file called glyr_wrap.c
> swig -ruby glyr.i 

# Compile the wrapper code, -I is the includedir of the Ruby headers, -fpic is needed
> gcc -c glyr_wrap.c -I /usr/include/ruby-1.9.1 -I/usr/include/ruby-1.9.1/x86_64-linux -I. -fpic

# Create the library by adding all other objects
> gcc -shared $(find ../lib/CMakeFiles -name "*.o") glyr_wrap.o -o glyr.so -lcurl

If everything went fine you should have a 'glubyr.so' in this directory.
No you can load it in Ruby:

> irb -r rubygems
>>> require './glubyr'
>>> Glubyr::version() 
=> "Version 0.2 (Kleptomaniacal Magpie) of [Feb 27 2011] compiled at [23:47:29]"
>>> exit

The subdir 'ruby' contains a wrapper class you can easily use to start right off:

# Short demo:

# Create a new query object
gluby = Glubyr.new

# configure gluby, those are exactly like the cmdoptions of glyrc 
gluby.number = 3 # Get 3 items 
gluby.quiet!     # Don't print what's up

# Get covers of the album "Sagas" from "Equilibrium" and store them in resultArray
# (which is a plain ruby array)
resultArray = gluby.getCover("equilibrium","sagas")

# The result_array contains now 0 - 3 (depending on how many items glyr could find)
# Each item is GlyMemCache object, which has the following members
#  data - (String)  the downloaded data, in this case a jpg file (it's a string because in C it is a char *)
#  size - (Integer) length of $data
#  dsrc - (String)  The exact URL from where the parser got this item. ( www.amazon.com/H634HUF/lala.jpg e.g)
# ------
# $data may be readable text with lyrics,similiar,review getters, but is unreadable with cover/photos
# ------
# Glubyr offers a binary write method
# Ruby can do this itself also, but rather
# inconvienent, use this for images only.
#
img_counter = 0
resultArray.each do |a|
    img_counter += 1
    path = "example_#{img_counter}.jpg"
    # Download is optional and user defined. 
    print "Content is at: #{a.data}\n" unless gluby.download?
    print "Saving #{a.dsrc} to #{path}\n" if gluby.download?
    gluby.writeBinaryCache(path,a)
end

# destroy object to test finalize() call
gluby = nil

## --- ##
This will store 3 images in the current working dir. 
