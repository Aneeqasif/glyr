.TH "GlyQuery" 3 "Thu Aug 4 2011" "Version 0.6" "libglyr" \" -*- nroff -*-
.ad l
.nh
.SH NAME
GlyQuery \- 
.PP
Structure controlling all of libglyr's options.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <types.h>\fP
.SS "Data Fields"

.in +1c
.ti -1c
.RI "enum \fBGLYR_GET_TYPE\fP \fBtype\fP"
.br
.ti -1c
.RI "int \fBnumber\fP"
.br
.ti -1c
.RI "int \fBplugmax\fP"
.br
.ti -1c
.RI "int \fBverbosity\fP"
.br
.ti -1c
.RI "size_t \fBfuzzyness\fP"
.br
.ti -1c
.RI "struct {"
.br
.ti -1c
.RI "   int \fBmin_size\fP"
.br
.ti -1c
.RI "   int \fBmax_size\fP"
.br
.ti -1c
.RI "} \fBcover\fP"
.br
.ti -1c
.RI "long \fBparallel\fP"
.br
.ti -1c
.RI "long \fBtimeout\fP"
.br
.ti -1c
.RI "long \fBredirects\fP"
.br
.ti -1c
.RI "bool \fBdownload\fP"
.br
.ti -1c
.RI "float \fBqsratio\fP"
.br
.ti -1c
.RI "struct {"
.br
.ti -1c
.RI "   enum \fBGLYR_ERROR\fP(* \fBdownload\fP )(\fBGlyMemCache\fP *dl, struct \fBGlyQuery\fP *s)"
.br
.ti -1c
.RI "   void * \fBuser_pointer\fP"
.br
.ti -1c
.RI "} \fBcallback\fP"
.br
.ti -1c
.RI "const char * \fBlang\fP"
.br
.RI "\fIanonymous struct holding the source and target lang for gtrans If source is NULL, autodetection will be enabled,
.br
 target has to be !NULL to enable translating \fP"
.ti -1c
.RI "const char * \fBproxy\fP"
.br
.ti -1c
.RI "char * \fBartist\fP"
.br
.ti -1c
.RI "char * \fBalbum\fP"
.br
.ti -1c
.RI "char * \fBtitle\fP"
.br
.ti -1c
.RI "char * \fBfrom\fP"
.br
.ti -1c
.RI "char * \fBallowed_formats\fP"
.br
.ti -1c
.RI "int \fBitemctr\fP"
.br
.ti -1c
.RI "char * \fBinfo\fP [10]"
.br
.ti -1c
.RI "bool \fBimagejob\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Structure controlling all of libglyr's options. 

You should modify this with the glyr_opt_* methods,
.br
 You can read all members directly.
.br
 Look up the corresponding glyr_opt_$name methods for more details. For reading: Dynamically allocated members are stored in '.alloc'! 
.SH "Field Documentation"
.PP 
.SS "char* \fBGlyQuery::album\fP"album field 
.SS "char* \fBGlyQuery::allowed_formats\fP"Allowed formats for images, given as semicolon sperated list 'png;jpeg;gif' 
.SS "char* \fBGlyQuery::artist\fP"artist field 
.SS "struct { ... }   \fBGlyQuery::callback\fP"
.SS "struct { ... }   \fBGlyQuery::cover\fP"
.SS "bool \fBGlyQuery::download\fP"return only urls without downloading, converting glyr to a sort of search engine 
.SS "enum \fBGLYR_ERROR\fP(*  \fBGlyQuery::download\fP)(\fBGlyMemCache\fP *dl, struct \fBGlyQuery\fP *s)"
.SS "char* \fBGlyQuery::from\fP"String passed to \fBglyr_opt_from()\fP 
.SS "size_t \fBGlyQuery::fuzzyness\fP"Treshold for Levenshtein algorithm 
.SS "bool \fBGlyQuery::imagejob\fP"
.SS "char* \fBGlyQuery::info\fP[10]"Do not use! - A register where porinters to all dynamic alloc. fields are saved. Do not use. 
.SS "int \fBGlyQuery::itemctr\fP"Do not use! - Counter of already received items - you shouldn't need this 
.SS "const char* \fBGlyQuery::lang\fP"
.PP
anonymous struct holding the source and target lang for gtrans If source is NULL, autodetection will be enabled,
.br
 target has to be !NULL to enable translating language settings (for amazon / google / last.fm) 
.SS "int \fBGlyQuery::max_size\fP"Max size a cover may have 
.SS "int \fBGlyQuery::min_size\fP"Min size a cover may have 
.SS "int \fBGlyQuery::number\fP"Number of items to download 
.SS "long \fBGlyQuery::parallel\fP"Max parallel downloads 
.SS "int \fBGlyQuery::plugmax\fP"Number of items a single provider may download 
.SS "const char* \fBGlyQuery::proxy\fP"Proxy settings 
.SS "float \fBGlyQuery::qsratio\fP"Weight speed or quality more, 0.0 = fullspeed; 1.0 = highest quality only 
.SS "long \fBGlyQuery::redirects\fP"Max redirects for downloads 
.SS "long \fBGlyQuery::timeout\fP"Max timeout for downloads 
.SS "char* \fBGlyQuery::title\fP"title field 
.SS "enum \fBGLYR_GET_TYPE\fP \fBGlyQuery::type\fP"What type of data to get 
.SS "void* \fBGlyQuery::user_pointer\fP"
.SS "int \fBGlyQuery::verbosity\fP"See \fBglyr_opt_verbosity()\fP for all levels 

.SH "Author"
.PP 
Generated automatically by Doxygen for libglyr from the source code.
