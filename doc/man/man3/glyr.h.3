.TH "lib/glyr.h" 3 "Thu Aug 4 2011" "Version 0.6" "libglyr" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lib/glyr.h \- 
.PP
All method declaration here. You should only need to include this file.  

.SH SYNOPSIS
.br
.PP
\fC#include 'types.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBglyr_init\fP (void)"
.br
.RI "\fIcall this at startup. This is not threadsafe and glyr_cleanup should be called once for everytime you call glyr_init Actually this method is only there to initialize libcurl, glyr only depends on the settings struct. \fP"
.ti -1c
.RI "void \fBglyr_cleanup\fP (void)"
.br
.RI "\fICall this at program termination. It's adviseable to call 'atexit(glyr_cleanup)' after \fBglyr_init()\fP Not threadsafe also. \fP"
.ti -1c
.RI "\fBGlyMemCache\fP * \fBglyr_get\fP (\fBGlyQuery\fP *settings, enum \fBGLYR_ERROR\fP *error, int *length)"
.br
.RI "\fIThe 'main' method of glyr. It starts the searching according to the settings in the settings param. \fP"
.ti -1c
.RI "void \fBglyr_init_query\fP (\fBGlyQuery\fP *glyrs)"
.br
.RI "\fIInit's the \fBGlyQuery\fP structure to sane defaults. Call this after creating the variable. \fP"
.ti -1c
.RI "void \fBglyr_destroy_query\fP (\fBGlyQuery\fP *sets)"
.br
.RI "\fIFree all memory associated with this query, and restore default settings. Do this always when you're done with this one. \fP"
.ti -1c
.RI "void \fBglyr_free_list\fP (\fBGlyMemCache\fP *head)"
.br
.RI "\fIFree the memory in the GlyCacheList returned by glyr_get. \fP"
.ti -1c
.RI "\fBGlyMemCache\fP * \fBglyr_new_cache\fP (void)"
.br
.RI "\fIReturns a newly allocated and initialized \fBGlyMemCache\fP, mostly for use with glyr_gtrans_* Don't forget to free it with glyr_free_cache. \fP"
.ti -1c
.RI "\fBGlyMemCache\fP * \fBglyr_copy_cache\fP (\fBGlyMemCache\fP *source)"
.br
.RI "\fIProduces an exact copy of the \fBGlyMemCache\fP source. \fP"
.ti -1c
.RI "void \fBglyr_free_cache\fP (\fBGlyMemCache\fP *c)"
.br
.RI "\fIFree the \fBGlyMemCache\fP pointed to by c. You should set it to NULL also, as using it after this will crash your program. \fP"
.ti -1c
.RI "enum \fBGLYR_ERROR\fP \fBglyr_opt_dlcallback\fP (\fBGlyQuery\fP *settings, \fBDL_callback\fP dl_cb, void *userp)"
.br
.RI "\fISet the callback that is executed once an item is ready downloaded. \fP"
.ti -1c
.RI "enum \fBGLYR_ERROR\fP \fBglyr_opt_type\fP (\fBGlyQuery\fP *s, enum \fBGLYR_GET_TYPE\fP type)"
.br
.RI "\fIWhat type of metadata to search for. Must be one of GLYR_GET_TYPE enum. \fP"
.ti -1c
.RI "enum \fBGLYR_ERROR\fP \fBglyr_opt_artist\fP (\fBGlyQuery\fP *s, char *artist)"
.br
.RI "\fIThe artist field. libglyr will try to format it to fit the best. \fP"
.ti -1c
.RI "enum \fBGLYR_ERROR\fP \fBglyr_opt_album\fP (\fBGlyQuery\fP *s, char *album)"
.br
.RI "\fIThe album field. libglyr will try to format it to fit the best. \fP"
.ti -1c
.RI "enum \fBGLYR_ERROR\fP \fBglyr_opt_title\fP (\fBGlyQuery\fP *s, char *title)"
.br
.RI "\fIThe title field. libglyr will try to format it to fit the best. \fP"
.ti -1c
.RI "enum \fBGLYR_ERROR\fP \fBglyr_opt_cmaxsize\fP (\fBGlyQuery\fP *s, int size)"
.br
.RI "\fIMaximum size a cover may have (assuming the cover is quadratic, only one size is required) \fP"
.ti -1c
.RI "enum \fBGLYR_ERROR\fP \fBglyr_opt_cminsize\fP (\fBGlyQuery\fP *s, int size)"
.br
.RI "\fIMinimum size a cover may have (assuming the cover is quadratic, only one size is required) \fP"
.ti -1c
.RI "enum \fBGLYR_ERROR\fP \fBglyr_opt_parallel\fP (\fBGlyQuery\fP *s, unsigned long val)"
.br
.RI "\fIThe number of items that may be downloaded in parallel. \fP"
.ti -1c
.RI "enum \fBGLYR_ERROR\fP \fBglyr_opt_timeout\fP (\fBGlyQuery\fP *s, unsigned long val)"
.br
.RI "\fIAmout of seconds to wait before cancelling an download. \fP"
.ti -1c
.RI "enum \fBGLYR_ERROR\fP \fBglyr_opt_redirects\fP (\fBGlyQuery\fP *s, unsigned long val)"
.br
.RI "\fIMax number of redirects to. \fP"
.ti -1c
.RI "enum \fBGLYR_ERROR\fP \fBglyr_opt_lang\fP (\fBGlyQuery\fP *s, char *langcode)"
.br
.RI "\fISet the language the items should be in. \fP"
.ti -1c
.RI "enum \fBGLYR_ERROR\fP \fBglyr_opt_number\fP (\fBGlyQuery\fP *s, unsigned int num)"
.br
.RI "\fISet the number of items to search. \fP"
.ti -1c
.RI "enum \fBGLYR_ERROR\fP \fBglyr_opt_verbosity\fP (\fBGlyQuery\fP *s, unsigned int level)"
.br
.RI "\fISet libglyr's verbosity level (debug) \fP"
.ti -1c
.RI "enum \fBGLYR_ERROR\fP \fBglyr_opt_from\fP (\fBGlyQuery\fP *s, const char *from)"
.br
.RI "\fIDefine the providers you want to use. \fP"
.ti -1c
.RI "enum \fBGLYR_ERROR\fP \fBglyr_opt_plugmax\fP (\fBGlyQuery\fP *s, int plugmax)"
.br
.RI "\fIDefine the maximum number of items a provider may download. \fP"
.ti -1c
.RI "enum \fBGLYR_ERROR\fP \fBglyr_opt_allowed_formats\fP (\fBGlyQuery\fP *s, const char *formats)"
.br
.RI "\fIDefine allowed image formats. \fP"
.ti -1c
.RI "enum \fBGLYR_ERROR\fP \fBglyr_opt_download\fP (\fBGlyQuery\fP *s, bool download)"
.br
.RI "\fIDefine if image items (i.e, covers, photos) are downloaded. \fP"
.ti -1c
.RI "enum \fBGLYR_ERROR\fP \fBglyr_opt_fuzzyness\fP (\fBGlyQuery\fP *s, int fuzz)"
.br
.RI "\fISet the max. tolerance for fuzzy matching. \fP"
.ti -1c
.RI "enum \fBGLYR_ERROR\fP \fBglyr_opt_qsratio\fP (\fBGlyQuery\fP *s, float ratio)"
.br
.RI "\fIWeight ratio between speed and quality. \fP"
.ti -1c
.RI "enum \fBGLYR_ERROR\fP \fBglyr_opt_proxy\fP (\fBGlyQuery\fP *s, const char *proxystring)"
.br
.RI "\fISet the proxy to use. \fP"
.ti -1c
.RI "\fBGlyMemCache\fP * \fBglyr_download\fP (const char *url, \fBGlyQuery\fP *s)"
.br
.RI "\fIA convinience method to download the content at the URl $url, according to the settings in $s Actually only the redirect and timeout parameters are used here. \fP"
.ti -1c
.RI "const char * \fBglyr_strerror\fP (enum \fBGLYR_ERROR\fP ID)"
.br
.RI "\fIMany methods use an returnvalue, or error parameters to inform you about errors Use this method to get a descriptive message you can print. \fP"
.ti -1c
.RI "const char * \fBglyr_version\fP (void)"
.br
.RI "\fIReturns versioning information, including compiletime. \fP"
.ti -1c
.RI "int \fBglyr_write\fP (\fBGlyMemCache\fP *data, const char *path)"
.br
.RI "\fIWrites data to a specified path. \fP"
.ti -1c
.RI "void \fBglyr_update_md5sum\fP (\fBGlyMemCache\fP *c)"
.br
.RI "\fIUpdates the md5sum field of the cache c. \fP"
.ti -1c
.RI "void \fBglyr_printitem\fP (\fBGlyQuery\fP *s, \fBGlyMemCache\fP *cacheditem)"
.br
.ti -1c
.RI "\fBGlyFetcherInfo\fP * \fBglyr_get_plugin_info\fP (void)"
.br
.RI "\fIget information about existing Fetcher and Source \fP"
.ti -1c
.RI "void \fBglyr_free_plugin_info\fP (\fBGlyFetcherInfo\fP **info)"
.br
.RI "\fIFree the data from \fBglyr_get_plugin_info()\fP \fP"
.in -1c
.SH "Detailed Description"
.PP 
All method declaration here. You should only need to include this file. 

All stable API of libglyr is right here.
.PP
\fBAuthor:\fP
.RS 4
Christopher Pahl 
.RE
.PP
\fBVersion:\fP
.RS 4
0.6 
.RE
.PP
\fBDate:\fP
.RS 4
2011-06-14 
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "void glyr_cleanup (void)"
.PP
Call this at program termination. It's adviseable to call 'atexit(glyr_cleanup)' after \fBglyr_init()\fP Not threadsafe also. 
.SS "\fBGlyMemCache\fP* glyr_copy_cache (\fBGlyMemCache\fP *source)"
.PP
Produces an exact copy of the \fBGlyMemCache\fP source. \fBParameters:\fP
.RS 4
\fIsource\fP The \fBGlyMemCache\fP to copy
.RE
.PP
\fBReturns:\fP
.RS 4
A newly allocated \fBGlyMemCache\fP 
.RE
.PP

.SS "void glyr_destroy_query (\fBGlyQuery\fP *sets)"
.PP
Free all memory associated with this query, and restore default settings. Do this always when you're done with this one. \fBParameters:\fP
.RS 4
\fIsets\fP The \fBGlyQuery\fP to be destroyed 
.RE
.PP

.SS "\fBGlyMemCache\fP* glyr_download (const char *url, \fBGlyQuery\fP *s)"
.PP
A convinience method to download the content at the URl $url, according to the settings in $s Actually only the redirect and timeout parameters are used here. \fBParameters:\fP
.RS 4
\fIurl\fP The url to download as nullterminated string. Must be a vaild URL. 
.br
\fIs\fP A \fBGlyQuery\fP with the timeout and redirect values filled to your needs.
.RE
.PP
\fBReturns:\fP
.RS 4
A \fBGlyMemCache\fP containing the data 
.RE
.PP

.SS "void glyr_free_cache (\fBGlyMemCache\fP *c)"
.PP
Free the \fBGlyMemCache\fP pointed to by c. You should set it to NULL also, as using it after this will crash your program. \fBParameters:\fP
.RS 4
\fIc\fP An allocated \fBGlyMemCache\fP 
.RE
.PP

.SS "void glyr_free_list (\fBGlyMemCache\fP *head)"
.PP
Free the memory in the GlyCacheList returned by glyr_get. \fBParameters:\fP
.RS 4
\fIhead\fP The GlyCacheList to be free'd 
.RE
.PP

.SS "void glyr_free_plugin_info (\fBGlyFetcherInfo\fP **info)"
.PP
Free the data from \fBglyr_get_plugin_info()\fP This method also set the pointer to NULL, for safety reasons.
.PP
\fBParameters:\fP
.RS 4
\fIinfo\fP A reference to the return value fo \fBglyr_get_plugin_info()\fP 
.RE
.PP

.SS "\fBGlyMemCache\fP* glyr_get (\fBGlyQuery\fP *settings, enum \fBGLYR_ERROR\fP *error, int *length)"
.PP
The 'main' method of glyr. It starts the searching according to the settings in the settings param. \fBParameters:\fP
.RS 4
\fIsettings\fP The setting struct controlling glyr. (See the glyr_opt_* methods) 
.br
\fIerror\fP An optional pointer to an int, which gets filled with an error message, or GLYRE_OK on success 
.br
\fIlength\fP An optional pointer storing the length of the returned list
.RE
.PP
It takes a pointer to a \fBGlyQuery\fP struct filled to your needs via the glyr_opt_* methods,
.br
 Once an item is found the callback (set via glyr_opt_dlcallback) is called with the item as parameter.
.br
 After return all items are listed in a GlyCacheList ready to be accessed, remember to delete it with glyr_free_list when done.
.br
.PP
\fBReturns:\fP
.RS 4
A GlyCacheList containing all found data. See the struct reference for further details. 
.RE
.PP

.SS "\fBGlyFetcherInfo\fP* glyr_get_plugin_info (void)"
.PP
get information about existing Fetcher and Source A Doubly linked list of Fetcher is returned, each having a field 'head', being a pointer to a doubly linked list of GlySourceInfos
.PP
\fBReturns:\fP
.RS 4
A newly \fBGlyFetcherInfo\fP structure, you can iterate over. 
.RE
.PP

.SS "void glyr_init (void)"
.PP
call this at startup. This is not threadsafe and glyr_cleanup should be called once for everytime you call glyr_init Actually this method is only there to initialize libcurl, glyr only depends on the settings struct. 
.SS "void glyr_init_query (\fBGlyQuery\fP *glyrs)"
.PP
Init's the \fBGlyQuery\fP structure to sane defaults. Call this after creating the variable. \fBParameters:\fP
.RS 4
\fIglyrs\fP The fresh \fBGlyQuery\fP to be init'd. 
.RE
.PP

.SS "\fBGlyMemCache\fP* glyr_new_cache (void)"
.PP
Returns a newly allocated and initialized \fBGlyMemCache\fP, mostly for use with glyr_gtrans_* Don't forget to free it with glyr_free_cache. \fBReturns:\fP
.RS 4
A newly allocated \fBGlyMemCache\fP 
.RE
.PP

.SS "enum \fBGLYR_ERROR\fP glyr_opt_album (\fBGlyQuery\fP *s, char *album)"
.PP
The album field. libglyr will try to format it to fit the best. \fBParameters:\fP
.RS 4
\fIs\fP The \fBGlyQuery\fP settings struct to store this option in. 
.br
\fIalbum\fP A nullterminated char, a copy of the string will be held internally so you can savely modify your version.
.RE
.PP
Required for the following getters:
.IP "\(bu" 2
albumlist
.IP "\(bu" 2
cover
.IP "\(bu" 2
review
.IP "\(bu" 2
tracklist
.PP
.PP
Optional for those:
.IP "\(bu" 2
tags
.IP "\(bu" 2
relations
.PP
.PP
lyrics
.PP
\fBReturns:\fP
.RS 4
an errorID 
.RE
.PP

.SS "enum \fBGLYR_ERROR\fP glyr_opt_allowed_formats (\fBGlyQuery\fP *s, const char *formats)"
.PP
Define allowed image formats. \fBParameters:\fP
.RS 4
\fIs\fP The \fBGlyQuery\fP settings struct to store this option in. 
.br
\fIformats\fP A comma seperated list of format specifiers, e.g. 'png;jpeg'
.RE
.PP
Awaits a string with a semicolon seperated list of allowed formats.
.br
 The case of the format is ignored.
.br
.PP
Example:
.br
 'png;jpg' would allow png,jpeg,jpg,JPEG,jpg, but not gifs.
.br
 The names of the format are the MIME types found in HTTP headers. A list of types is here: http://www.w3schools.com/media/media_mimeref.asp
.PP
A value of NULL will default to 'png;jpeg;tiff'
.PP
\fBReturns:\fP
.RS 4
an errorID 
.RE
.PP

.SS "enum \fBGLYR_ERROR\fP glyr_opt_artist (\fBGlyQuery\fP *s, char *artist)"
.PP
The artist field. libglyr will try to format it to fit the best. \fBParameters:\fP
.RS 4
\fIs\fP The \fBGlyQuery\fP settings struct to store this option in 
.br
\fIartist\fP A nullterminated char, a copy of the string will be held internally so you can savely modify your version.
.RE
.PP
This field is required for all getters. You are required to fill it.
.PP
\fBReturns:\fP
.RS 4
an errorID 
.RE
.PP

.SS "enum \fBGLYR_ERROR\fP glyr_opt_cmaxsize (\fBGlyQuery\fP *s, intsize)"
.PP
Maximum size a cover may have (assuming the cover is quadratic, only one size is required) \fBParameters:\fP
.RS 4
\fIs\fP The \fBGlyQuery\fP settings struct to store this option in. 
.br
\fIsize\fP The max. size in pixel
.RE
.PP
Please note: libglyr takes this as a hint, and not as an absolute measure. You may find yourself with slightly oversized or undersized covers,
.br
 but generally overall in the range between cmin and cmax. Also, this only works for the 'cover' getter, not for 'photos'!
.br
.PP
\fBReturns:\fP
.RS 4
an errorID 
.RE
.PP

.SS "enum \fBGLYR_ERROR\fP glyr_opt_cminsize (\fBGlyQuery\fP *s, intsize)"
.PP
Minimum size a cover may have (assuming the cover is quadratic, only one size is required) \fBParameters:\fP
.RS 4
\fIs\fP The \fBGlyQuery\fP settings struct to store this option in. 
.br
\fIsize\fP The min. size in pixel
.RE
.PP
Note: Also see \fBglyr_opt_cmaxsize()\fP
.PP
\fBReturns:\fP
.RS 4
an errorID 
.RE
.PP

.SS "enum \fBGLYR_ERROR\fP glyr_opt_dlcallback (\fBGlyQuery\fP *settings, \fBDL_callback\fPdl_cb, void *userp)"
.PP
Set the callback that is executed once an item is ready downloaded. \fBParameters:\fP
.RS 4
\fIsettings\fP The \fBGlyQuery\fP settings struct to store this option in 
.br
\fIdl_cb\fP The callback to register, must have a prototype like this:
.br
 enum GLYR_ERROR my_callback(GlyMemCache * dl, struct GlyQuery * s); 
.br
\fIuserp\fP A pointer to a custom variable you can access inside the callback via s->callback.user_pointer;
.RE
.PP
Note that you can return a certain integer in the callback:
.br
 GLYRE_IGNORE: To not add this item to the results. GLYRE_OK: To add this item to the results and continue happily. GLYRE_STOP_BY_CB: To stop right now and return the results. The last element will NOT be added.
.PP
\fBReturns:\fP
.RS 4
an errorID 
.RE
.PP

.SS "enum \fBGLYR_ERROR\fP glyr_opt_download (\fBGlyQuery\fP *s, booldownload)"
.PP
Define if image items (i.e, covers, photos) are downloaded. \fBParameters:\fP
.RS 4
\fIs\fP The \fBGlyQuery\fP settings struct to store this option in. 
.br
\fIdownload\fP For image getters only.
.br
 If set to true images are also coviniently downloaded and returned.
.br
 Otherwise, just the URL is returned for your own use.
.br
.RE
.PP
Default to 'true', 'false' would be a bit more searchengine like.
.br
.PP
\fBReturns:\fP
.RS 4
an errorID 
.RE
.PP

.SS "enum \fBGLYR_ERROR\fP glyr_opt_from (\fBGlyQuery\fP *s, const char *from)"
.PP
Define the providers you want to use. \fBParameters:\fP
.RS 4
\fIs\fP The \fBGlyQuery\fP settings struct to store this option in. 
.br
\fIfrom\fP a string, see below
.RE
.PP
Use this to define what providers you want to use.
.br
 Every provider has a name and a key which is merely a shortcut for the name.
.br
 Specify all providers in a semicolon seperated list.
.br
 Type 'glyrc -H' for a complete list of all providers for each getter.
.br
.PP
Example:
.br
 'amazon;google' 
.br
 'a;g' - same with keys
.br
.PP
You can also prepend each word with a '+' or a '-' ('+' is assumend without),
.br
 which will add or remove this provider from the list respectively.
.br
 Additionally you may use the predefined groups 'safe','unsafe','fast','slow','special'.
.br
.PP
Example:
.br
 '+fast;-amazon' which will enable last.fm and lyricswiki.
.br
.PP
\fBReturns:\fP
.RS 4
an errorID 
.RE
.PP

.SS "enum \fBGLYR_ERROR\fP glyr_opt_fuzzyness (\fBGlyQuery\fP *s, intfuzz)"
.PP
Set the max. tolerance for fuzzy matching. \fBParameters:\fP
.RS 4
\fIs\fP The \fBGlyQuery\fP settings struct to store this option in. 
.br
\fIfuzz\fP Set the maximum amount of inserts, edits and substitutions, a search results
.br
 may differ from the artist and/or album and/or title.
.br
 The difference between two strings is measured as the 'Levenshtein distance',
.br
 i.e, the total amount of inserts,edits and substitutes needed to convert string a to b.
.br
.RE
.PP
Example:
.br
 'Equilibrium' <=> 'Aqilibriums' => Distance=3
.br
 With a fuzzyness of 3 this would pass the check, with 2 it won't.
.br
.PP
Higher values mean more search results, but more inaccuracy. 
.br
 Default is 4.
.PP
\fBReturns:\fP
.RS 4
an errorID 
.RE
.PP

.SS "enum \fBGLYR_ERROR\fP glyr_opt_lang (\fBGlyQuery\fP *s, char *langcode)"
.PP
Set the language the items should be in. \fBParameters:\fP
.RS 4
\fIs\fP The \fBGlyQuery\fP settings struct to store this option in. 
.br
\fIlangcode\fP The language used for providers with multilingual content. It is given in ISO-639-1 codes, i.e 'de','en','fr' etc.
.RE
.PP
List of providers recognizing this option:
.br
 * cover/amazon (which amazon server to query) * cover/google (which google server to query) * ainfo/lastfm (the language the biography shall be in)
.br
.PP
(Use only these providers if you really want ONLY localized content)
.br
 If no language specified the language defaults to english ('en')
.PP
Note1: This only works with a few providers, which should be set via \fBglyr_opt_from()\fP Note2: Don't coinfuse this with the built-in google translator's settings.
.PP
\fBReturns:\fP
.RS 4
an errorID 
.RE
.PP

.SS "enum \fBGLYR_ERROR\fP glyr_opt_number (\fBGlyQuery\fP *s, unsigned intnum)"
.PP
Set the number of items to search. \fBParameters:\fP
.RS 4
\fIs\fP The \fBGlyQuery\fP settings struct to store this option in. 
.br
\fInum\fP the number as an integer
.RE
.PP
How many items to search for (1 to INT_MAX)
.br
 This is not the number of items actually returned then,
.br
 because libglyr is not able to find 300 songtexts of the same song,
.br
 or libglyr filters duplicate items before returning.
.br
 It will try to get as close to this number, but not higher. If '0' is specified, libglyr will try to find all the things.
.PP
\fBReturns:\fP
.RS 4
an errorID 
.RE
.PP

.SS "enum \fBGLYR_ERROR\fP glyr_opt_parallel (\fBGlyQuery\fP *s, unsigned longval)"
.PP
The number of items that may be downloaded in parallel. \fBParameters:\fP
.RS 4
\fIs\fP The \fBGlyQuery\fP settings struct to store this option in. 
.br
\fIval\fP the number as unsigned long
.RE
.PP
\fBReturns:\fP
.RS 4
an errorID 
.RE
.PP

.SS "enum \fBGLYR_ERROR\fP glyr_opt_plugmax (\fBGlyQuery\fP *s, intplugmax)"
.PP
Define the maximum number of items a provider may download. \fBParameters:\fP
.RS 4
\fIs\fP The \fBGlyQuery\fP settings struct to store this option in. 
.br
\fIplugmax\fP Use this to scatter the results over more providers, to get different results.
.br
 You can set it also to -1 what allows an infinite number of items (=> default)
.RE
.PP
\fBReturns:\fP
.RS 4
an errorID 
.RE
.PP

.SS "enum \fBGLYR_ERROR\fP glyr_opt_proxy (\fBGlyQuery\fP *s, const char *proxystring)"
.PP
Set the proxy to use. \fBParameters:\fP
.RS 4
\fIs\fP The \fBGlyQuery\fP settings struct to store this option in. 
.br
\fIproxystring\fP the proxy setting.
.RE
.PP
NULL for none, otherwise see the documentation of curl_easy_setopt(CURLOPT_PROXY) how to set this. Synatx: [protocol://][user:pass@]Domain[:port] Example: 'http://Proxy.fh-hof.de:3128'
.PP
If empty the global env $http_proxy shall be used, if present.
.PP
\fBReturns:\fP
.RS 4
an errorID 
.RE
.PP

.SS "enum \fBGLYR_ERROR\fP glyr_opt_qsratio (\fBGlyQuery\fP *s, floatratio)"
.PP
Weight ratio between speed and quality. \fBParameters:\fP
.RS 4
\fIs\fP The \fBGlyQuery\fP settings struct to store this option in. 
.br
\fIratio\fP A float, where 0.0 if full speed, and 1.0 full quality
.RE
.PP
0.00 means highest speed, you're kinda lucky if you have the right result there. 1.00 Takes possibly longer, but delivers usually good results. 0.85 is the current default value.
.PP
All other values, smaller 0.0, greater 1.0 are clamped to 0.0 / 1.0
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.SS "enum \fBGLYR_ERROR\fP glyr_opt_redirects (\fBGlyQuery\fP *s, unsigned longval)"
.PP
Max number of redirects to. \fBParameters:\fP
.RS 4
\fIs\fP The \fBGlyQuery\fP settings struct to store this option in. 
.br
\fIval\fP an unsigned integer
.RE
.PP
A value of 0 is allowed, but may break certain plugins.
.br
 Default = 1
.PP
\fBReturns:\fP
.RS 4
an errorID 
.RE
.PP

.SS "enum \fBGLYR_ERROR\fP glyr_opt_timeout (\fBGlyQuery\fP *s, unsigned longval)"
.PP
Amout of seconds to wait before cancelling an download. \fBParameters:\fP
.RS 4
\fIs\fP The \fBGlyQuery\fP settings struct to store this option in. 
.br
\fIval\fP Timeout in seconds.
.RE
.PP
If more than one item is downloaded in parallel, the timeout will be changed accordingly.
.br
 Default is 20 seconds.
.PP
\fBReturns:\fP
.RS 4
an errorID 
.RE
.PP

.SS "enum \fBGLYR_ERROR\fP glyr_opt_title (\fBGlyQuery\fP *s, char *title)"
.PP
The title field. libglyr will try to format it to fit the best. \fBParameters:\fP
.RS 4
\fIs\fP The \fBGlyQuery\fP settings struct to store this option in. 
.br
\fItitle\fP A nullterminated char, a copy of the string will be held internally so you can savely modify your version.
.RE
.PP
Required for:
.IP "\(bu" 2
lyrics Optional for:
.IP "\(bu" 2
tags
.IP "\(bu" 2
relations
.PP
.PP
\fBReturns:\fP
.RS 4
an errorID 
.RE
.PP

.SS "enum \fBGLYR_ERROR\fP glyr_opt_type (\fBGlyQuery\fP *s, enum \fBGLYR_GET_TYPE\fPtype)"
.PP
What type of metadata to search for. Must be one of GLYR_GET_TYPE enum. \fBParameters:\fP
.RS 4
\fIs\fP The \fBGlyQuery\fP settings struct to store this option in 
.br
\fItype\fP A member of the GLYR_GET_TYPE enum, set this before you set anything else.
.RE
.PP
\fBReturns:\fP
.RS 4
an errorID 
.RE
.PP

.SS "enum \fBGLYR_ERROR\fP glyr_opt_verbosity (\fBGlyQuery\fP *s, unsigned intlevel)"
.PP
Set libglyr's verbosity level (debug) \fBParameters:\fP
.RS 4
\fIs\fP The \fBGlyQuery\fP settings struct to store this option in. 
.br
\fIlevel\fP The level as an integer, see description below
.RE
.PP
0) nothing but fatal errors.
.br
 1) warnings and important notes.
.br
 2) normal, additional information what libglyr does.
.br
 3) basic debug output.
.br
 4) libcurl debug output.
.br
.PP
\fBReturns:\fP
.RS 4
an errorID 
.RE
.PP

.SS "void glyr_printitem (\fBGlyQuery\fP *s, \fBGlyMemCache\fP *cacheditem)"\fBParameters:\fP
.RS 4
\fIs\fP 
.br
\fIcacheditem\fP 
.RE
.PP

.SS "const char* glyr_strerror (enum \fBGLYR_ERROR\fPID)"
.PP
Many methods use an returnvalue, or error parameters to inform you about errors Use this method to get a descriptive message you can print. \fBParameters:\fP
.RS 4
\fIID\fP The returned error
.RE
.PP
\fBReturns:\fP
.RS 4
A descriptive nullterminated string, do not pass to free 
.RE
.PP

.SS "void glyr_update_md5sum (\fBGlyMemCache\fP *c)"
.PP
Updates the md5sum field of the cache c. \fBParameters:\fP
.RS 4
\fIc\fP a valid memcahe 
.RE
.PP

.SS "const char* glyr_version (void)"
.PP
Returns versioning information, including compiletime. Example: 
.br
 Version 0.4 (Larcenous Locust (dev)) of [May 20 2011] compiled at [19:12:37]
.PP
\fBReturns:\fP
.RS 4
A nullterminated string, do not free 
.RE
.PP

.SS "int glyr_write (\fBGlyMemCache\fP *data, const char *path)"
.PP
Writes data to a specified path. \fBParameters:\fP
.RS 4
\fIdata\fP The data to write. 
.br
\fIpath\fP The path to write data at.
.RE
.PP
Writes data to path $path, special values for $path can be 'stdout','stderr' or 'null',
.br
 which are pretty selfexplaining.
.PP
\fBReturns:\fP
.RS 4
An error id. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for libglyr from the source code.
