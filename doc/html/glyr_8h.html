<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libglyr: lib/glyr.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">libglyr
   &#160;<span id="projectnumber">0.8</span>
   </div>
   <div id="projectbrief">A music related metadata searchengine and library</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_2dc4c6fbea07b9bc3ab918a9951ebb66.html">lib</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">glyr.h File Reference</div>  </div>
</div>
<div class="contents">

<p>All method declaration here. You should only need to include this file.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="types_8h_source.html">types.h</a>&quot;</code><br/>
</div>
<p><a href="glyr_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#af4e64a53d273b91a3f704db26c254016">glyr_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">call this at startup This is not threadsafe and glyr_cleanup should be called once for everytime you call glyr_init<br/>
 Actually this method is only there to initialize libcurl, glyr only depends on the settings struct.<br/>
  <a href="#af4e64a53d273b91a3f704db26c254016"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a7d9cffb8f2bce83e72ca73fe98b76d3a">glyr_cleanup</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this at program termination. It's adviseable to call 'atexit(glyr_cleanup)' after <a class="el" href="glyr_8h.html#af4e64a53d273b91a3f704db26c254016" title="call this at startup This is not threadsafe and glyr_cleanup should be called once for everytime you ...">glyr_init()</a><br/>
 Not threadsafe!<br/>
.  <a href="#a7d9cffb8f2bce83e72ca73fe98b76d3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structGlyrMemCache.html">GlyrMemCache</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a64938c9f0f0745232e4555864d53c074">glyr_get</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *settings, enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> *error, int *length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The 'main' method of glyr. It starts the searching according to the settings in the settings param.  <a href="#a64938c9f0f0745232e4555864d53c074"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a7237980f8b5ad40826f2a7e9a2cc9b95">glyr_init_query</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *glyrs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Init's the <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> structure to sane defaults. Call this after creating the variable.  <a href="#a7237980f8b5ad40826f2a7e9a2cc9b95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a1a97e1c0dd917b6e7e3d2221884aaa21">glyr_destroy_query</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *sets)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all memory associated with this query, and restore default settings. Do this always when you're done with this one.  <a href="#a1a97e1c0dd917b6e7e3d2221884aaa21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a7721d1581dca81e623e3a4c5c87bf3c0">glyr_free_list</a> (<a class="el" href="structGlyrMemCache.html">GlyrMemCache</a> *head)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory in the GlyCacheList returned by glyr_get.  <a href="#a7721d1581dca81e623e3a4c5c87bf3c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structGlyrMemCache.html">GlyrMemCache</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a0ab4149b417585435870ed331a572bde">glyr_new_cache</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a newly allocated and initialized <a class="el" href="structGlyrMemCache.html" title="Represents a single item.">GlyrMemCache</a>, mostly for use with glyr_gtrans_* Don't forget to free it with glyr_free_cache.  <a href="#a0ab4149b417585435870ed331a572bde"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structGlyrMemCache.html">GlyrMemCache</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a03a1061b102e98815fe3e83fc182af21">glyr_copy_cache</a> (<a class="el" href="structGlyrMemCache.html">GlyrMemCache</a> *source)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces an exact copy of the <a class="el" href="structGlyrMemCache.html" title="Represents a single item.">GlyrMemCache</a> source.  <a href="#a03a1061b102e98815fe3e83fc182af21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#abad0acccf1078e02d69358ba0aac6594">glyr_free_cache</a> (<a class="el" href="structGlyrMemCache.html">GlyrMemCache</a> *c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the <a class="el" href="structGlyrMemCache.html" title="Represents a single item.">GlyrMemCache</a> pointed to by c. You should set it to NULL also, as using it after this will crash your program.  <a href="#abad0acccf1078e02d69358ba0aac6594"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a014206990796e5a08e8d082172339e54">glyr_opt_dlcallback</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *settings, <a class="el" href="types_8h.html#ad020ef38c522b5d55800fcc13ed23d6b">DL_callback</a> dl_cb, void *userp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback that is executed once an item is ready downloaded.  <a href="#a014206990796e5a08e8d082172339e54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a698203fcc51af1a6b45aa80c787a3bdb">glyr_opt_type</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *s, enum <a class="el" href="types_8h.html#a10514a32d3df08c9165d5ed7d15589a9">GLYR_GET_TYPE</a> type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">What type of metadata to search for. Must be one of GLYR_GET_TYPE enum.  <a href="#a698203fcc51af1a6b45aa80c787a3bdb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a7e7cec5b1d98111d34a2aa390f2a91de">glyr_opt_artist</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *s, char *artist)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The artist field. libglyr will try to format it to fit the best.  <a href="#a7e7cec5b1d98111d34a2aa390f2a91de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a542f2c52af49b918bc733923fac4a370">glyr_opt_album</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *s, char *album)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The album field. libglyr will try to format it to fit the best.  <a href="#a542f2c52af49b918bc733923fac4a370"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a484f52bbe1ab5cb27cbc7706186ca63f">glyr_opt_title</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *s, char *title)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The title field. libglyr will try to format it to fit the best.  <a href="#a484f52bbe1ab5cb27cbc7706186ca63f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#ac0f469f9219a84793ac137d10810e12d">glyr_opt_img_minsize</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *s, int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size a cover may have (assuming the cover is quadratic, only one size is required)  <a href="#ac0f469f9219a84793ac137d10810e12d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#ad34eccf943d71cc6b00c2cc0b5f74d0e">glyr_opt_img_maxsize</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *s, int size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum size a image-item may have (assuming the image is quadratic, only one size is required)  <a href="#ad34eccf943d71cc6b00c2cc0b5f74d0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#af21cd563597b2e84ebc4316d903a52bf">glyr_opt_parallel</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *s, unsigned long val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of jobs that may be started in parallel.  <a href="#af21cd563597b2e84ebc4316d903a52bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#aaaeb01c3bd21484646baf9e1bcd83b80">glyr_opt_timeout</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *s, unsigned long val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Amout of seconds to wait before cancelling an download.  <a href="#aaaeb01c3bd21484646baf9e1bcd83b80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a051bbf331729a8dfa660719cde42b1ea">glyr_opt_redirects</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *s, unsigned long val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Max number of redirects to.  <a href="#a051bbf331729a8dfa660719cde42b1ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a8bf6f7acb95d73fbf4b442f84e5f3e8a">glyr_opt_useragent</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *s, const char *useragent)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the useragent during making progresses.  <a href="#a8bf6f7acb95d73fbf4b442f84e5f3e8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a9ba153159e9299c61666c794450b577b">glyr_opt_lang</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *s, char *langcode)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Language for providers offering multilingual data.  <a href="#a9ba153159e9299c61666c794450b577b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#adf66cce99e239cf09cb9a1a7b33db886">glyr_opt_number</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *s, unsigned int num)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of items to search.  <a href="#adf66cce99e239cf09cb9a1a7b33db886"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a57bcf0e3ced30e6eebf66b824ab919ca">glyr_opt_verbosity</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *s, unsigned int level)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set libglyr's verbosity level (debug)  <a href="#a57bcf0e3ced30e6eebf66b824ab919ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#aec95b71b8c8600e2c18e8085aa3a7828">glyr_opt_from</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *s, const char *from)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the providers you want to use.  <a href="#aec95b71b8c8600e2c18e8085aa3a7828"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#ad7b16272ba211bec8287291e132aa9e3">glyr_opt_plugmax</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *s, int plugmax)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the maximum number of items a provider may download.  <a href="#ad7b16272ba211bec8287291e132aa9e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a39f21b55e6e315de429e83f745be9ce4">glyr_opt_allowed_formats</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *s, const char *formats)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define allowed image formats.  <a href="#a39f21b55e6e315de429e83f745be9ce4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#aad870e0063af25805a1d0b06e9d0b4d1">glyr_opt_download</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *s, bool download)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Define if image items (i.e, covers, photos) are downloaded.  <a href="#aad870e0063af25805a1d0b06e9d0b4d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#af6979be701a7ff36dbe8a8700e700ebb">glyr_opt_fuzzyness</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *s, int fuzz)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the max. tolerance for fuzzy matching.  <a href="#af6979be701a7ff36dbe8a8700e700ebb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a9db3be92e7792b655ce4de5c1833fddd">glyr_opt_qsratio</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *s, float ratio)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Weight ratio between speed and quality.  <a href="#a9db3be92e7792b655ce4de5c1833fddd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#acc62f0fb4eaaab58a6583ad90f1324fd">glyr_opt_proxy</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *s, const char *proxystring)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the proxy to use.  <a href="#acc62f0fb4eaaab58a6583ad90f1324fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#ace9492b13393b5567430906235b054ef">glyr_opt_force_utf8</a> (<a class="el" href="structGlyrQuery.html">GlyrQuery</a> *s, bool force_utf8)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces UTF8 encoding for text items.  <a href="#ace9492b13393b5567430906235b054ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structGlyrMemCache.html">GlyrMemCache</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#acf48e5a67d693d4bdb7466bd12b3b101">glyr_download</a> (const char *url, <a class="el" href="structGlyrQuery.html">GlyrQuery</a> *s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convinience method to download the content at the URl $url, according to the settings in $s Actually only the redirect and timeout parameters are used here.  <a href="#acf48e5a67d693d4bdb7466bd12b3b101"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a607c30104138c4ac10aff26f1d26abcf">glyr_strerror</a> (enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> ID)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Many methods use an returnvalue, or error parameters to inform you about errors Use this method to get a descriptive message you can print.  <a href="#a607c30104138c4ac10aff26f1d26abcf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a85eb1ffcd7fbc67ab6859a6d417d34f2">glyr_version</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns versioning information, including compiletime.  <a href="#a85eb1ffcd7fbc67ab6859a6d417d34f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a05275ff9463c6b976af9612ddcdc7e5d">glyr_write</a> (<a class="el" href="structGlyrMemCache.html">GlyrMemCache</a> *data, const char *path)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data to a specified path.  <a href="#a05275ff9463c6b976af9612ddcdc7e5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a8c3b1c72a83b2d6e4b4f26c0f6746566">glyr_update_md5sum</a> (<a class="el" href="structGlyrMemCache.html">GlyrMemCache</a> *c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the md5sum field of the cache c.  <a href="#a8c3b1c72a83b2d6e4b4f26c0f6746566"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a979ac294589edf61ccd52d3014104dba">glyr_printitem</a> (<a class="el" href="structGlyrMemCache.html">GlyrMemCache</a> *cacheditem)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints information about a <a class="el" href="structGlyrMemCache.html" title="Represents a single item.">GlyrMemCache</a> to stderr.  <a href="#a979ac294589edf61ccd52d3014104dba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structGlyrFetcherInfo.html">GlyrFetcherInfo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a6267f47c303050a0b45b751ef85cc882">glyr_get_plugin_info</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get information about existing Fetcher and Source  <a href="#a6267f47c303050a0b45b751ef85cc882"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#aef7523dcec0808735d903bc017cfccd6">glyr_free_plugin_info</a> (<a class="el" href="structGlyrFetcherInfo.html">GlyrFetcherInfo</a> **info)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the data from <a class="el" href="glyr_8h.html#a6267f47c303050a0b45b751ef85cc882" title="get information about existing Fetcher and Source">glyr_get_plugin_info()</a>  <a href="#aef7523dcec0808735d903bc017cfccd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glyr_8h.html#a77ee283dad7a7893a0b29598845de115">glyr_type_to_string</a> (enum <a class="el" href="types_8h.html#aed6a85dbaccaf17531f2b57700ea23c2">GLYR_DATA_TYPE</a> type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a GLYR_DATA_TYPE type to a string.  <a href="#a77ee283dad7a7893a0b29598845de115"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>All method declaration here. You should only need to include this file. </p>
<p>All stable API of libglyr is right here.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Christopher Pahl </dd></dl>
<dl class="version"><dt><b>Version:</b></dt><dd>0.6 </dd></dl>
<dl class="date"><dt><b>Date:</b></dt><dd>2011-06-14 </dd></dl>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a7d9cffb8f2bce83e72ca73fe98b76d3a"></a><!-- doxytag: member="glyr.h::glyr_cleanup" ref="a7d9cffb8f2bce83e72ca73fe98b76d3a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glyr_cleanup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Call this at program termination. It's adviseable to call 'atexit(glyr_cleanup)' after <a class="el" href="glyr_8h.html#af4e64a53d273b91a3f704db26c254016" title="call this at startup This is not threadsafe and glyr_cleanup should be called once for everytime you ...">glyr_init()</a><br/>
 Not threadsafe!<br/>
. </p>

</div>
</div>
<a class="anchor" id="a03a1061b102e98815fe3e83fc182af21"></a><!-- doxytag: member="glyr.h::glyr_copy_cache" ref="a03a1061b102e98815fe3e83fc182af21" args="(GlyrMemCache *source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGlyrMemCache.html">GlyrMemCache</a>* glyr_copy_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrMemCache.html">GlyrMemCache</a> *&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Produces an exact copy of the <a class="el" href="structGlyrMemCache.html" title="Represents a single item.">GlyrMemCache</a> source. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The <a class="el" href="structGlyrMemCache.html" title="Represents a single item.">GlyrMemCache</a> to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A newly allocated <a class="el" href="structGlyrMemCache.html" title="Represents a single item.">GlyrMemCache</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1a97e1c0dd917b6e7e3d2221884aaa21"></a><!-- doxytag: member="glyr.h::glyr_destroy_query" ref="a1a97e1c0dd917b6e7e3d2221884aaa21" args="(GlyrQuery *sets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glyr_destroy_query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>sets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free all memory associated with this query, and restore default settings. Do this always when you're done with this one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sets</td><td>The <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> to be destroyed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf48e5a67d693d4bdb7466bd12b3b101"></a><!-- doxytag: member="glyr.h::glyr_download" ref="acf48e5a67d693d4bdb7466bd12b3b101" args="(const char *url, GlyrQuery *s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGlyrMemCache.html">GlyrMemCache</a>* glyr_download </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A convinience method to download the content at the URl $url, according to the settings in $s Actually only the redirect and timeout parameters are used here. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>The url to download as nullterminated string. Must be a vaild URL. </td></tr>
    <tr><td class="paramname">s</td><td>A <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> with the timeout and redirect values filled to your needs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="structGlyrMemCache.html" title="Represents a single item.">GlyrMemCache</a> containing the data </dd></dl>

</div>
</div>
<a class="anchor" id="abad0acccf1078e02d69358ba0aac6594"></a><!-- doxytag: member="glyr.h::glyr_free_cache" ref="abad0acccf1078e02d69358ba0aac6594" args="(GlyrMemCache *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glyr_free_cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrMemCache.html">GlyrMemCache</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free the <a class="el" href="structGlyrMemCache.html" title="Represents a single item.">GlyrMemCache</a> pointed to by c. You should set it to NULL also, as using it after this will crash your program. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>An allocated <a class="el" href="structGlyrMemCache.html" title="Represents a single item.">GlyrMemCache</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7721d1581dca81e623e3a4c5c87bf3c0"></a><!-- doxytag: member="glyr.h::glyr_free_list" ref="a7721d1581dca81e623e3a4c5c87bf3c0" args="(GlyrMemCache *head)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glyr_free_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrMemCache.html">GlyrMemCache</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free the memory in the GlyCacheList returned by glyr_get. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>The GlyCacheList to be free'd </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef7523dcec0808735d903bc017cfccd6"></a><!-- doxytag: member="glyr.h::glyr_free_plugin_info" ref="aef7523dcec0808735d903bc017cfccd6" args="(GlyrFetcherInfo **info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glyr_free_plugin_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrFetcherInfo.html">GlyrFetcherInfo</a> **&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free the data from <a class="el" href="glyr_8h.html#a6267f47c303050a0b45b751ef85cc882" title="get information about existing Fetcher and Source">glyr_get_plugin_info()</a> </p>
<p>This method also set the pointer to NULL, for safety reasons.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>A reference to the return value fo <a class="el" href="glyr_8h.html#a6267f47c303050a0b45b751ef85cc882" title="get information about existing Fetcher and Source">glyr_get_plugin_info()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64938c9f0f0745232e4555864d53c074"></a><!-- doxytag: member="glyr.h::glyr_get" ref="a64938c9f0f0745232e4555864d53c074" args="(GlyrQuery *settings, enum GLYR_ERROR *error, int *length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGlyrMemCache.html">GlyrMemCache</a>* glyr_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> *&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The 'main' method of glyr. It starts the searching according to the settings in the settings param. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">settings</td><td>The setting struct controlling glyr. (See the glyr_opt_* methods) </td></tr>
    <tr><td class="paramname">error</td><td>An optional pointer to an int, which gets filled with an error message, or GLYRE_OK on success </td></tr>
    <tr><td class="paramname">length</td><td>An optional pointer storing the length of the returned list</td></tr>
  </table>
  </dd>
</dl>
<p>It takes a pointer to a <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> struct filled to your needs via the glyr_opt_* methods,<br/>
 Once an item is found the callback (set via glyr_opt_dlcallback) is called with the item as parameter.<br/>
 After return all items are listed in a GlyCacheList ready to be accessed, remember to delete it with glyr_free_list when done.<br/>
</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A GlyCacheList containing all found data. See the struct reference for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="a6267f47c303050a0b45b751ef85cc882"></a><!-- doxytag: member="glyr.h::glyr_get_plugin_info" ref="a6267f47c303050a0b45b751ef85cc882" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGlyrFetcherInfo.html">GlyrFetcherInfo</a>* glyr_get_plugin_info </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get information about existing Fetcher and Source </p>
<p>A Doubly linked list of Fetcher is returned, each having a field 'head', being a pointer to a doubly linked list of GlyrSourceInfos</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A newly <a class="el" href="structGlyrFetcherInfo.html">GlyrFetcherInfo</a> structure, you can iterate over. </dd></dl>

</div>
</div>
<a class="anchor" id="af4e64a53d273b91a3f704db26c254016"></a><!-- doxytag: member="glyr.h::glyr_init" ref="af4e64a53d273b91a3f704db26c254016" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glyr_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>call this at startup This is not threadsafe and glyr_cleanup should be called once for everytime you call glyr_init<br/>
 Actually this method is only there to initialize libcurl, glyr only depends on the settings struct.<br/>
 </p>

</div>
</div>
<a class="anchor" id="a7237980f8b5ad40826f2a7e9a2cc9b95"></a><!-- doxytag: member="glyr.h::glyr_init_query" ref="a7237980f8b5ad40826f2a7e9a2cc9b95" args="(GlyrQuery *glyrs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glyr_init_query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>glyrs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Init's the <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> structure to sane defaults. Call this after creating the variable. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">glyrs</td><td>The fresh <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> to be init'd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ab4149b417585435870ed331a572bde"></a><!-- doxytag: member="glyr.h::glyr_new_cache" ref="a0ab4149b417585435870ed331a572bde" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structGlyrMemCache.html">GlyrMemCache</a>* glyr_new_cache </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a newly allocated and initialized <a class="el" href="structGlyrMemCache.html" title="Represents a single item.">GlyrMemCache</a>, mostly for use with glyr_gtrans_* Don't forget to free it with glyr_free_cache. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A newly allocated <a class="el" href="structGlyrMemCache.html" title="Represents a single item.">GlyrMemCache</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a542f2c52af49b918bc733923fac4a370"></a><!-- doxytag: member="glyr.h::glyr_opt_album" ref="a542f2c52af49b918bc733923fac4a370" args="(GlyrQuery *s, char *album)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> glyr_opt_album </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>album</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The album field. libglyr will try to format it to fit the best. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> settings struct to store this option in. </td></tr>
    <tr><td class="paramname">album</td><td>A nullterminated char, a copy of the string will be held internally so you can savely modify your version.</td></tr>
  </table>
  </dd>
</dl>
<p>Required for the following getters:</p>
<ul>
<li>albumlist</li>
<li>cover</li>
<li>albumreview</li>
</ul>
<p>similarsongs</p>
<ul>
<li>tracklist</li>
</ul>
<p>Optional for those:</p>
<ul>
<li>tags</li>
<li>relations</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>an errorID </dd></dl>

</div>
</div>
<a class="anchor" id="a39f21b55e6e315de429e83f745be9ce4"></a><!-- doxytag: member="glyr.h::glyr_opt_allowed_formats" ref="a39f21b55e6e315de429e83f745be9ce4" args="(GlyrQuery *s, const char *formats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> glyr_opt_allowed_formats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>formats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define allowed image formats. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> settings struct to store this option in. </td></tr>
    <tr><td class="paramname">formats</td><td>A comma seperated list of format specifiers, e.g. "png;jpeg"</td></tr>
  </table>
  </dd>
</dl>
<p>Awaits a string with a semicolon seperated list of allowed formats.<br/>
 The case of the format is ignored.<br/>
</p>
<p>Example:<br/>
 "png;jpg" would allow png,jpeg,jpg,JPEG,jpg, but not gifs.<br/>
 The names of the format are the MIME types found in HTTP headers. A list of types is here: <a href="http://www.w3schools.com/media/media_mimeref.asp">http://www.w3schools.com/media/media_mimeref.asp</a></p>
<p>A value of NULL will default to "png;jpeg;tiff"</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an errorID </dd></dl>

</div>
</div>
<a class="anchor" id="a7e7cec5b1d98111d34a2aa390f2a91de"></a><!-- doxytag: member="glyr.h::glyr_opt_artist" ref="a7e7cec5b1d98111d34a2aa390f2a91de" args="(GlyrQuery *s, char *artist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> glyr_opt_artist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>artist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The artist field. libglyr will try to format it to fit the best. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> settings struct to store this option in </td></tr>
    <tr><td class="paramname">artist</td><td>A nullterminated char, a copy of the string will be held internally so you can savely modify your version.</td></tr>
  </table>
  </dd>
</dl>
<p>This field is required for all getters. You are required to fill it.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an errorID </dd></dl>

</div>
</div>
<a class="anchor" id="a014206990796e5a08e8d082172339e54"></a><!-- doxytag: member="glyr.h::glyr_opt_dlcallback" ref="a014206990796e5a08e8d082172339e54" args="(GlyrQuery *settings, DL_callback dl_cb, void *userp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> glyr_opt_dlcallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#ad020ef38c522b5d55800fcc13ed23d6b">DL_callback</a>&#160;</td>
          <td class="paramname"><em>dl_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the callback that is executed once an item is ready downloaded. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">settings</td><td>The <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> settings struct to store this option in </td></tr>
    <tr><td class="paramname">dl_cb</td><td>The callback to register, must have a prototype like this:<br/>
 enum GLYR_ERROR my_callback(GlyrMemCache * dl, struct GlyrQuery * s); </td></tr>
    <tr><td class="paramname">userp</td><td>A pointer to a custom variable you can access inside the callback via s-&gt;callback.user_pointer;</td></tr>
  </table>
  </dd>
</dl>
<p>Note that you can return a certain integer in the callback:<br/>
 GLYRE_IGNORE: To not add this item to the results. GLYRE_OK: To add this item to the results and continue happily. GLYRE_STOP_BY_CB: To stop right now and return the results. The last element will NOT be added.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an errorID </dd></dl>

</div>
</div>
<a class="anchor" id="aad870e0063af25805a1d0b06e9d0b4d1"></a><!-- doxytag: member="glyr.h::glyr_opt_download" ref="aad870e0063af25805a1d0b06e9d0b4d1" args="(GlyrQuery *s, bool download)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> glyr_opt_download </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>download</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define if image items (i.e, covers, photos) are downloaded. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> settings struct to store this option in. </td></tr>
    <tr><td class="paramname">download</td><td>For image getters only.<br/>
 If set to true images are also coviniently downloaded and returned.<br/>
 Otherwise, just the URL is returned for your own use.<br/>
</td></tr>
  </table>
  </dd>
</dl>
<p>Default to 'true', 'false' would be a bit more searchengine like.<br/>
</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an errorID </dd></dl>

</div>
</div>
<a class="anchor" id="ace9492b13393b5567430906235b054ef"></a><!-- doxytag: member="glyr.h::glyr_opt_force_utf8" ref="ace9492b13393b5567430906235b054ef" args="(GlyrQuery *s, bool force_utf8)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> glyr_opt_force_utf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force_utf8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Forces UTF8 encoding for text items. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>A <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> with the timeout and redirect values filled to your needs. </td></tr>
    <tr><td class="paramname">force_utf8</td><td>true to foce, false to accept other encodings</td></tr>
  </table>
  </dd>
</dl>
<p>Often this will option won't have serious impact, except for a view providers that don't deliever exact UTF8, due to corrupted data (twice encoded like metrolyrics), but may deliever subsets of UTF8. Check is done via g_utf8_validate()</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="structGlyrMemCache.html" title="Represents a single item.">GlyrMemCache</a> containing the data </dd></dl>

</div>
</div>
<a class="anchor" id="aec95b71b8c8600e2c18e8085aa3a7828"></a><!-- doxytag: member="glyr.h::glyr_opt_from" ref="aec95b71b8c8600e2c18e8085aa3a7828" args="(GlyrQuery *s, const char *from)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> glyr_opt_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define the providers you want to use. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> settings struct to store this option in. </td></tr>
    <tr><td class="paramname">from</td><td>a string, see below</td></tr>
  </table>
  </dd>
</dl>
<p>Use this to define what providers you want to use.<br/>
 Every provider has a name and a key which is merely a shortcut for the name.<br/>
 Specify all providers in a semicolon seperated list.<br/>
 Type 'glyrc -H' for a complete list of all providers for each getter.<br/>
</p>
<p>Example:<br/>
 "amazon;google" <br/>
 "a;g" - same with keys<br/>
</p>
<p>You can also prepend each word with a '+' or a '-' ('+' is assumend without),<br/>
 which will add or remove this provider from the list respectively.<br/>
 Additionally you may use the predefined groups 'safe','unsafe','fast','slow','special'.<br/>
</p>
<p>Example:<br/>
 "+fast;-amazon" which will enable last.fm and lyricswiki.<br/>
</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an errorID </dd></dl>

</div>
</div>
<a class="anchor" id="af6979be701a7ff36dbe8a8700e700ebb"></a><!-- doxytag: member="glyr.h::glyr_opt_fuzzyness" ref="af6979be701a7ff36dbe8a8700e700ebb" args="(GlyrQuery *s, int fuzz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> glyr_opt_fuzzyness </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fuzz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the max. tolerance for fuzzy matching. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> settings struct to store this option in. </td></tr>
    <tr><td class="paramname">fuzz</td><td>Set the maximum amount of inserts, edits and substitutions, a search results<br/>
 may differ from the artist and/or album and/or title.<br/>
 The difference between two strings is measured as the 'Levenshtein distance',<br/>
 i.e, the total amount of inserts,edits and substitutes needed to convert string a to b.<br/>
</td></tr>
  </table>
  </dd>
</dl>
<p>Example:<br/>
 "Equilibrium" &lt;=&gt; "Aqilibriums" =&gt; Distance=3<br/>
 With a fuzzyness of 3 this would pass the check, with 2 it won't.<br/>
</p>
<p>Higher values mean more search results, but more inaccuracy. <br/>
 Default is 4.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an errorID </dd></dl>

</div>
</div>
<a class="anchor" id="ad34eccf943d71cc6b00c2cc0b5f74d0e"></a><!-- doxytag: member="glyr.h::glyr_opt_img_maxsize" ref="ad34eccf943d71cc6b00c2cc0b5f74d0e" args="(GlyrQuery *s, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> glyr_opt_img_maxsize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Minimum size a image-item may have (assuming the image is quadratic, only one size is required) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> settings struct to store this option in. </td></tr>
    <tr><td class="paramname">size</td><td>The min. size in pixel</td></tr>
  </table>
  </dd>
</dl>
<p>Note: Also see <a class="el" href="glyr_8h.html#ad34eccf943d71cc6b00c2cc0b5f74d0e" title="Minimum size a image-item may have (assuming the image is quadratic, only one size is required)...">glyr_opt_img_maxsize()</a></p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an errorID </dd></dl>

</div>
</div>
<a class="anchor" id="ac0f469f9219a84793ac137d10810e12d"></a><!-- doxytag: member="glyr.h::glyr_opt_img_minsize" ref="ac0f469f9219a84793ac137d10810e12d" args="(GlyrQuery *s, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> glyr_opt_img_minsize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Maximum size a cover may have (assuming the cover is quadratic, only one size is required) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> settings struct to store this option in. </td></tr>
    <tr><td class="paramname">size</td><td>The max. size in pixel</td></tr>
  </table>
  </dd>
</dl>
<p>Please note: libglyr takes this as a hint, and not as an absolute measure. You may find yourself with slightly oversized or undersized covers,<br/>
 but generally overall in the range between min and max. <br/>
</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an errorID </dd></dl>

</div>
</div>
<a class="anchor" id="a9ba153159e9299c61666c794450b577b"></a><!-- doxytag: member="glyr.h::glyr_opt_lang" ref="a9ba153159e9299c61666c794450b577b" args="(GlyrQuery *s, char *langcode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> glyr_opt_lang </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>langcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Language for providers offering multilingual data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> settings struct to store this option in. </td></tr>
    <tr><td class="paramname">langcode</td><td>The language used for providers with multilingual content. It is given in ISO-639-1 codes, i.e 'de','en','fr' etc.</td></tr>
  </table>
  </dd>
</dl>
<p>List of providers recognizing this option:<br/>
 * cover/amazon (which amazon server to query) * cover/google (which google server to query) * ainfo/lastfm (the language the biography shall be in)<br/>
</p>
<p>(Use only these providers if you really want ONLY localized content)<br/>
 If no language specified the language defaults to english ("en")<br/>
 The special value 'auto' is recognized, in which case the language will be<br/>
 guessed from your current locale.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an errorID </dd></dl>

</div>
</div>
<a class="anchor" id="adf66cce99e239cf09cb9a1a7b33db886"></a><!-- doxytag: member="glyr.h::glyr_opt_number" ref="adf66cce99e239cf09cb9a1a7b33db886" args="(GlyrQuery *s, unsigned int num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> glyr_opt_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the number of items to search. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> settings struct to store this option in. </td></tr>
    <tr><td class="paramname">num</td><td>the number as an integer</td></tr>
  </table>
  </dd>
</dl>
<p>How many items to search for (1 to INT_MAX)<br/>
 This is not the number of items actually returned then,<br/>
 because libglyr is not able to find 300 songtexts of the same song,<br/>
 or libglyr filters duplicate items before returning.<br/>
 It will try to get as close to this number, but not higher. If '0' is specified, libglyr will try to find all the things.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an errorID </dd></dl>

</div>
</div>
<a class="anchor" id="af21cd563597b2e84ebc4316d903a52bf"></a><!-- doxytag: member="glyr.h::glyr_opt_parallel" ref="af21cd563597b2e84ebc4316d903a52bf" args="(GlyrQuery *s, unsigned long val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> glyr_opt_parallel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The number of jobs that may be started in parallel. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> settings struct to store this option in. </td></tr>
    <tr><td class="paramname">val</td><td>the number as unsigned long</td></tr>
  </table>
  </dd>
</dl>
<p>This does not acutally limit the number of parallel downloads,<br/>
 rather it limits the number of providers that are tried in parallel<br/>
 Set this to a value of 0 to let libglyr guess the best value.<br/>
</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an errorID </dd></dl>

</div>
</div>
<a class="anchor" id="ad7b16272ba211bec8287291e132aa9e3"></a><!-- doxytag: member="glyr.h::glyr_opt_plugmax" ref="ad7b16272ba211bec8287291e132aa9e3" args="(GlyrQuery *s, int plugmax)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> glyr_opt_plugmax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>plugmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Define the maximum number of items a provider may download. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> settings struct to store this option in. </td></tr>
    <tr><td class="paramname">plugmax</td><td>Use this to scatter the results over more providers, to get different results.<br/>
 You can set it also to -1 what allows an infinite number of items (=&gt; default)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an errorID </dd></dl>

</div>
</div>
<a class="anchor" id="acc62f0fb4eaaab58a6583ad90f1324fd"></a><!-- doxytag: member="glyr.h::glyr_opt_proxy" ref="acc62f0fb4eaaab58a6583ad90f1324fd" args="(GlyrQuery *s, const char *proxystring)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> glyr_opt_proxy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>proxystring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the proxy to use. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> settings struct to store this option in. </td></tr>
    <tr><td class="paramname">proxystring</td><td>the proxy setting.</td></tr>
  </table>
  </dd>
</dl>
<p>NULL for none, otherwise see the documentation of curl_easy_setopt(CURLOPT_PROXY) how to set this. Synatx: [protocol://][user:pass@]Domain[:port] Example: "http://Proxy.fh-hof.de:3128"</p>
<p>If empty the global env $http_proxy shall be used, if present.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an errorID </dd></dl>

</div>
</div>
<a class="anchor" id="a9db3be92e7792b655ce4de5c1833fddd"></a><!-- doxytag: member="glyr.h::glyr_opt_qsratio" ref="a9db3be92e7792b655ce4de5c1833fddd" args="(GlyrQuery *s, float ratio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> glyr_opt_qsratio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Weight ratio between speed and quality. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> settings struct to store this option in. </td></tr>
    <tr><td class="paramname">ratio</td><td>A float, where 0.0 if full speed, and 1.0 full quality</td></tr>
  </table>
  </dd>
</dl>
<p>0.00 means highest speed, you're kinda lucky if you have the right result there. 1.00 Takes possibly longer, but delivers usually good results. 0.85 is the current default value.</p>
<p>All other values, smaller 0.0, greater 1.0 are clamped to 0.0 / 1.0</p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a051bbf331729a8dfa660719cde42b1ea"></a><!-- doxytag: member="glyr.h::glyr_opt_redirects" ref="a051bbf331729a8dfa660719cde42b1ea" args="(GlyrQuery *s, unsigned long val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> glyr_opt_redirects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Max number of redirects to. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> settings struct to store this option in. </td></tr>
    <tr><td class="paramname">val</td><td>an unsigned integer</td></tr>
  </table>
  </dd>
</dl>
<p>A value of 0 is allowed, but may break certain plugins.<br/>
 Default = 1<br/>
</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an errorID </dd></dl>

</div>
</div>
<a class="anchor" id="aaaeb01c3bd21484646baf9e1bcd83b80"></a><!-- doxytag: member="glyr.h::glyr_opt_timeout" ref="aaaeb01c3bd21484646baf9e1bcd83b80" args="(GlyrQuery *s, unsigned long val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> glyr_opt_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Amout of seconds to wait before cancelling an download. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> settings struct to store this option in. </td></tr>
    <tr><td class="paramname">val</td><td>Timeout in seconds.</td></tr>
  </table>
  </dd>
</dl>
<p>If more than one item is downloaded in parallel, the timeout will be changed accordingly.<br/>
 Default is 20 seconds.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an errorID </dd></dl>

</div>
</div>
<a class="anchor" id="a484f52bbe1ab5cb27cbc7706186ca63f"></a><!-- doxytag: member="glyr.h::glyr_opt_title" ref="a484f52bbe1ab5cb27cbc7706186ca63f" args="(GlyrQuery *s, char *title)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> glyr_opt_title </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>title</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The title field. libglyr will try to format it to fit the best. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> settings struct to store this option in. </td></tr>
    <tr><td class="paramname">title</td><td>A nullterminated char, a copy of the string will be held internally so you can savely modify your version.</td></tr>
  </table>
  </dd>
</dl>
<p>Required for:</p>
<ul>
<li>lyrics Optional for:</li>
<li>tags</li>
<li>relations</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>an errorID </dd></dl>

</div>
</div>
<a class="anchor" id="a698203fcc51af1a6b45aa80c787a3bdb"></a><!-- doxytag: member="glyr.h::glyr_opt_type" ref="a698203fcc51af1a6b45aa80c787a3bdb" args="(GlyrQuery *s, enum GLYR_GET_TYPE type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> glyr_opt_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="types_8h.html#a10514a32d3df08c9165d5ed7d15589a9">GLYR_GET_TYPE</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>What type of metadata to search for. Must be one of GLYR_GET_TYPE enum. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> settings struct to store this option in </td></tr>
    <tr><td class="paramname">type</td><td>A member of the GLYR_GET_TYPE enum, set this before you set anything else.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an errorID </dd></dl>

</div>
</div>
<a class="anchor" id="a8bf6f7acb95d73fbf4b442f84e5f3e8a"></a><!-- doxytag: member="glyr.h::glyr_opt_useragent" ref="a8bf6f7acb95d73fbf4b442f84e5f3e8a" args="(GlyrQuery *s, const char *useragent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> glyr_opt_useragent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>useragent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the useragent during making progresses. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> settings struct to store this option in. </td></tr>
    <tr><td class="paramname">useragent</td><td>a null terminated string containging everything you want</td></tr>
  </table>
  </dd>
</dl>
<p>Some provider may require an useragent, setting it to an empty string "" <br/>
 might not be safe therefore<br/>
 Default useragents is "libglyr/&lt;version name&gt;" or similar</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an errorID </dd></dl>

</div>
</div>
<a class="anchor" id="a57bcf0e3ced30e6eebf66b824ab919ca"></a><!-- doxytag: member="glyr.h::glyr_opt_verbosity" ref="a57bcf0e3ced30e6eebf66b824ab919ca" args="(GlyrQuery *s, unsigned int level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a> glyr_opt_verbosity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrQuery.html">GlyrQuery</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set libglyr's verbosity level (debug) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The <a class="el" href="structGlyrQuery.html" title="Structure controlling all of libglyr&#39;s options.">GlyrQuery</a> settings struct to store this option in. </td></tr>
    <tr><td class="paramname">level</td><td>The level as an integer, see description below</td></tr>
  </table>
  </dd>
</dl>
<p>0) nothing but fatal errors.<br/>
 1) warnings and important notes.<br/>
 2) normal, additional information what libglyr does.<br/>
 3) basic debug output.<br/>
 4) libcurl debug output.<br/>
</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>an errorID </dd></dl>

</div>
</div>
<a class="anchor" id="a979ac294589edf61ccd52d3014104dba"></a><!-- doxytag: member="glyr.h::glyr_printitem" ref="a979ac294589edf61ccd52d3014104dba" args="(GlyrMemCache *cacheditem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glyr_printitem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrMemCache.html">GlyrMemCache</a> *&#160;</td>
          <td class="paramname"><em>cacheditem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prints information about a <a class="el" href="structGlyrMemCache.html" title="Represents a single item.">GlyrMemCache</a> to stderr. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cacheditem</td><td>The <a class="el" href="structGlyrMemCache.html" title="Represents a single item.">GlyrMemCache</a> to be printed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a607c30104138c4ac10aff26f1d26abcf"></a><!-- doxytag: member="glyr.h::glyr_strerror" ref="a607c30104138c4ac10aff26f1d26abcf" args="(enum GLYR_ERROR ID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* glyr_strerror </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="types_8h.html#a65c6c61a2d677f11ea7150a4f9ed78ab">GLYR_ERROR</a>&#160;</td>
          <td class="paramname"><em>ID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Many methods use an returnvalue, or error parameters to inform you about errors Use this method to get a descriptive message you can print. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ID</td><td>The returned error</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A descriptive nullterminated string, do not pass to free </dd></dl>

</div>
</div>
<a class="anchor" id="a77ee283dad7a7893a0b29598845de115"></a><!-- doxytag: member="glyr.h::glyr_type_to_string" ref="a77ee283dad7a7893a0b29598845de115" args="(enum GLYR_DATA_TYPE type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* glyr_type_to_string </td>
          <td>(</td>
          <td class="paramtype">enum <a class="el" href="types_8h.html#aed6a85dbaccaf17531f2b57700ea23c2">GLYR_DATA_TYPE</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts a GLYR_DATA_TYPE type to a string. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>a member of the GLYR_DATA_TYPE enum, TYPE_COVER_PRI e.g.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a statically allocated string, do not free </dd></dl>

</div>
</div>
<a class="anchor" id="a8c3b1c72a83b2d6e4b4f26c0f6746566"></a><!-- doxytag: member="glyr.h::glyr_update_md5sum" ref="a8c3b1c72a83b2d6e4b4f26c0f6746566" args="(GlyrMemCache *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void glyr_update_md5sum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrMemCache.html">GlyrMemCache</a> *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the md5sum field of the cache c. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>a valid memcahe </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85eb1ffcd7fbc67ab6859a6d417d34f2"></a><!-- doxytag: member="glyr.h::glyr_version" ref="a85eb1ffcd7fbc67ab6859a6d417d34f2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* glyr_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns versioning information, including compiletime. </p>
<p>Example: <br/>
 Version 0.4 (Larcenous Locust (dev)) of [May 20 2011] compiled at [19:12:37]</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A nullterminated string, do not free </dd></dl>

</div>
</div>
<a class="anchor" id="a05275ff9463c6b976af9612ddcdc7e5d"></a><!-- doxytag: member="glyr.h::glyr_write" ref="a05275ff9463c6b976af9612ddcdc7e5d" args="(GlyrMemCache *data, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int glyr_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGlyrMemCache.html">GlyrMemCache</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes data to a specified path. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to write. </td></tr>
    <tr><td class="paramname">path</td><td>The path to write data at.</td></tr>
  </table>
  </dd>
</dl>
<p>Writes data to path $path, special values for $path can be 'stdout','stderr' or 'null',<br/>
 which are pretty selfexplaining.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An error id. </dd></dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 21 2011 19:20:11 for libglyr by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5
</small></address>

</body>
</html>
